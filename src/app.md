# Application development

| Recipe | Crates | Categories |
|--------|--------|------------|
| [Parse command line arguments][ex-clap-basic] | [![clap-badge]][clap] | [![cat-command-line-badge]][cat-command-line] |
| [Log a debug message to the console][ex-log-debug] | [![log-badge]][log] [![env_logger-badge]][env_logger] | [![cat-debugging-badge]][cat-debugging] |
| [Log an error message to the console][ex-log-error] | [![log-badge]][log] [![env_logger-badge]][env_logger] | [![cat-debugging-badge]][cat-debugging] |
| [Enable log levels per module][ex-log-mod] | [![log-badge]][log] [![env_logger-badge]][env_logger] | [![cat-debugging-badge]][cat-debugging] |
| [Log messages with a custom logger][ex-log-custom-logger] | [![log-badge]][log] | [![cat-debugging-badge]][cat-debugging] |
| [Include timestamp in log messages][ex-log-timestamp] | [![log-badge]][log] [![env_logger-badge]][env_logger] [![chrono-badge]][chrono] | [![cat-debugging-badge]][cat-debugging] |
| [Log to the Unix syslog][ex-log-syslog] | [![log-badge]][log] [![syslog-badge]][syslog] | [![cat-debugging-badge]][cat-debugging] |
| [Log messages to a custom location][ex-log-custom] | [![log-badge]][log] | [![cat-debugging-badge]][cat-debugging] |
| [Unzip a tarball to a temporary directory][ex-tar-temp] | [![flate2-badge]][flate2] [![tar-badge]][tar] [![tempdir-badge]][tempdir] | [![cat-filesystem-badge]][cat-filesystem] [![cat-compression-badge]][cat-compression] |
| [Recursively find duplicate file names][ex-dedup-filenames] | [![walkdir-badge]][walkdir] | [![cat-filesystem-badge]][cat-filesystem] |
| [Recursively find all files with given predicate][ex-file-predicate] | [![walkdir-badge]][walkdir] | [![cat-filesystem-badge]][cat-filesystem] |

[ex-clap-basic]: #ex-clap-basic
<a name="ex-clap-basic"></a>
## Parse command line arguments

[![clap-badge]][clap] [![cat-command-line-badge]][cat-command-line]

```rust
extern crate clap;

use clap::{Arg, App};

fn main() {
    // Define command line arguments.
    let matches = App::new("My Test Program")
        .version("0.1.0")
        .author("Hackerman Jones <hckrmnjones@hack.gov>")
        .about("Teaches argument parsing")
        .arg(Arg::with_name("file")
                 .short("f")
                 .long("file")
                 .takes_value(true)
                 .help("A cool file"))
        .arg(Arg::with_name("num")
                 .short("n")
                 .long("number")
                 .takes_value(true)
                 .help("Five less than your favorite number"))
        .get_matches();

    // Get value for file, or default to 'input.txt'.
    let myfile = matches.value_of("file").unwrap_or("input.txt");
    println!("The file passed is: {}", myfile);

    // Get value for num if present, and try parsing it as i32.
    let num_str = matches.value_of("num");
    match num_str {
        None => println!("No idea what your favorite number is."),
        Some(s) => {
            match s.parse::<i32>() {
                Ok(n) => println!("Your favorite number must be {}.", n + 5),
                Err(_) => println!("That's not a number! {}", s),
            }
        }
    }
}
```

The `clap` crate is a simple-to-use, efficient, and full-featured library for
parsing command line arguments and subcommands when writing console/terminal
applications.

The application can describe the structure of its command-line interface using
`clap`'s builder style. The [documentation] gives two other possible ways to
instantiate an application.

[documentation]: https://docs.rs/clap/

In the builder style, `with_name` is the unique identifier that `value_of` will
use to retrieve the value passed. The `short` and `long` options control the
flag the user will be expected to type; short flags look like `-f` and long
flags look like `--file`.

Usage information is generated by `clap`. The usage for the example application
looks like this.

```
My Test Program 0.1.0
Hackerman Jones <hckrmnjones@hack.gov>
Teaches argument parsing

USAGE:
    testing [OPTIONS]

FLAGS:
    -h, --help       Prints help information
    -V, --version    Prints version information

OPTIONS:
    -f, --file <file>     A cool file
    -n, --number <num>    Five less than your favorite number
```

We can test the application by running a command like the following.

```
$ cargo run -- -f myfile.txt -n 251
```

The output is:

```
The file passed is: myfile.txt
Your favorite number must be 256.
```

[ex-log-debug]: #ex-log-debug
<a name="ex-log-debug"></a>
## Log a debug message to the console

[![log-badge]][log] [![env_logger-badge]][env_logger] [![cat-debugging-badge]][cat-debugging]

[Write me!](https://github.com/brson/rust-cookbook/issues/61)

[ex-log-error]: #ex-log-error
<a name="ex-log-error"></a>
## Log an error message to the console

[![log-badge]][log] [![env_logger-badge]][env_logger] [![cat-debugging-badge]][cat-debugging]

[Write me!](https://github.com/brson/rust-cookbook/issues/61)

[ex-log-mod]: #ex-log-mod
<a name="ex-log-mod"></a>
## Enable log levels per module

[![log-badge]][log] [![env_logger-badge]][env_logger] [![cat-debugging-badge]][cat-debugging]

```rust
# #[macro_use]
# extern crate error_chain;
#[macro_use]
extern crate log;
extern crate env_logger;

mod foo {
    mod bar {
        pub fn run() {
            warn!("[bar] warn");
            info!("[bar] info");
            debug!("[bar] debug");
        }
    }

    pub fn run() {
        warn!("[foo] warn");
        info!("[foo] info");
        debug!("[foo] debug");
        bar::run();
    }
}
#
# error_chain! {
#    foreign_links {
#        SetLogger(log::SetLoggerError);
#    }
# }

fn run() -> Result<()> {
    env_logger::init()?;
    warn!("[root] warn");
    info!("[root] info");
    debug!("[root] debug");
    foo::run();

    Ok(())
}
#
# quick_main!(run);
```

[`env_logger`][env_logger] output is controlled by [`RUST_LOG`] environmental
variable on per module basis with comma separated entries in format `path::to::module=log_level`.
Assuming application `test` is run as follows:

```
RUST_LOG="warn,test::foo=info,test::foo::bar=debug" ./test
```

The default [`log::LogLevel`] is set to `warn`, while log levels for module `foo` and nested module `foo::bar` are set respectively to `info` and `debug`.

The output is:

```
WARN:test: [root] warn
WARN:test::foo: [foo] warn
INFO:test::foo: [foo] info
WARN:test::foo::bar: [bar] warn
INFO:test::foo::bar: [bar] info
DEBUG:test::foo::bar: [bar] debug
```

[ex-log-custom-logger]: #ex-log-custom-logger
<a name="ex-log-custom-logger"></a>
## Log messages with a custom logger

[![log-badge]][log] [![cat-debugging-badge]][cat-debugging]

Custom logger `ConsoleLogger` is implemented with [`log::Log`] trait and installed 
via [`log::set_logger`]. Messages are logged to stdout.

```rust
# #[macro_use]
# extern crate error_chain;
#[macro_use]
extern crate log;

use log::{LogRecord, LogLevel, LogMetadata, LogLevelFilter};

struct ConsoleLogger;

impl log::Log for ConsoleLogger {
    fn enabled(&self, metadata: &LogMetadata) -> bool {
        metadata.level() <= LogLevel::Info
    }

    fn log(&self, record: &LogRecord) {
        if self.enabled(record.metadata()) {
            println!("Rust says: {} - {}", record.level(), record.args());
        }
    }
}
#
# error_chain! {
#    foreign_links {
#        SetLogger(log::SetLoggerError);
#    }
# }

fn run() -> Result<()> {
    log::set_logger(|max_log_level| {
                        max_log_level.set(LogLevelFilter::Info);
                        Box::new(ConsoleLogger)
                    })?;

    info!("hello log");
    warn!("warning");
    error!("oops");
    Ok(())
}
#
# quick_main!(run);
```

[ex-log-timestamp]: #ex-log-timestamp
<a name="ex-log-timestamp"></a>
## Include timestamp in log messages

[![log-badge]][log] [![env_logger-badge]][env_logger] [![chrono-badge]][chrono] [![cat-debugging-badge]][cat-debugging]

Creates a custom logger configuration with [`env_logger::LogBuilder`].
Each log entry calls [`Local::now`] to get the current [`DateTime`] in local timezone and uses [`DateTime::format`] with [`strftime::specifiers`] to format a timestamp used in the final log.

The example calls [`LogBuilder::format`] to set a closure which formats each
message text with timestamp, [`LogRecord::level`] and body ([`LogRecord::args`]).
Subsequently calls [`LogBuilder::parse`] which parses `MY_APP_LOG` environmental variable contents in the form of [`RUST_LOG`] syntax.
Finally calls [`LogBuilder::init`] to initialize the logger.
All these steps are normally done internally by [`env_logger::init`].

```rust
# #[macro_use]
# extern crate error_chain;
#[macro_use]
extern crate log;
extern crate env_logger;
extern crate chrono;

use chrono::Local;
use env_logger::LogBuilder;
use std::env;
#
# error_chain! {
#    foreign_links {
#        SetLogger(log::SetLoggerError);
#    }
# }

fn run() -> Result<()> {
    LogBuilder::new()
        .format(|record| {
                    format!("{} [{}] - {}",
                            Local::now().format("%a %b %e %T %Y"),
                            record.level(),
                            record.args())
                })
        .parse(&env::var("MY_APP_LOG").unwrap_or_default())
        .init()?;

    warn!("warn");
    info!("info");
    debug!("debug");
    Ok(())
}
#
# quick_main!(run);
```
Calling `MY_APP_LOG="info" cargo run` will result in similar output:
```
Sat May 20 20:54:55 2017 [WARN] - warn
Sat May 20 20:54:55 2017 [INFO] - info
```

[ex-log-syslog]: #ex-log-syslog
<a name="ex-log-syslog"></a>
## Log to the Unix syslog

[![log-badge]][log] [![syslog-badge]][syslog] [![cat-debugging-badge]][cat-debugging]

Messages are logged to [UNIX syslog]. Logger backend is initialized
with [`syslog::init`].
[`syslog::Facility`] indicates type of program submitting log.
[`log::LogLevelFilter`] denotes allowed log verbosity
and `Option<&str>` holds optional application name.

```rust,no_run
# #[macro_use]
# extern crate error_chain;
#[macro_use]
extern crate log;
extern crate syslog;

use log::LogLevelFilter;
use syslog::Facility;
#
# error_chain! {
#    foreign_links {
#        SetLogger(log::SetLoggerError);
#    }
# }

fn run() -> Result<()> {
    syslog::init(Facility::LOG_USER, LogLevelFilter::Debug, Some("My app name"))?;
    debug!("this is a debug {}", "message");
    error!("this is an error!");
    Ok(())
}
#
# quick_main!(run);
```

[ex-log-custom]: #ex-log-custom
<a name="ex-log-custom"></a>
## Log messages to a custom location

[![log-badge]][log] [![log4rs-badge]][log4rs] [![cat-debugging-badge]][cat-debugging]

Logs are configured to log to a custom location by using log4rs. log4rs can use either an external yaml file or a programmatically constructed configuration.

First log file configuration is created using [`log4rs::append::file::FileAppender`] using a custom pattern from [`log4rs::encode::pattern`].  

Then this is assigned to the [`log4rs::config::Config`] which has a root appender that uses the `logfile` appender that was just created, and sets the default [`log::LogLevelFilter`] so that any logs with `Info` level or higher will be sent to the logger.

```rust,no_run
# #[macro_use]
# extern crate error_chain;
#[macro_use]
extern crate log;
extern crate log4rs;

use log::LogLevelFilter;
use log4rs::append::file::FileAppender;
use log4rs::encode::pattern::PatternEncoder;
use log4rs::config::{Appender, Config, Root};
#
# error_chain! {
#    foreign_links {
#        Io(std::io::Error);
#        LogConfig(log4rs::config::Errors);
#        SetLogger(log::SetLoggerError);
#    }
# }

fn run() -> Result<()> {
    let logfile = FileAppender::builder()
        .encoder(Box::new(PatternEncoder::new("{l} - {m}\n")))
        .build("log/output.log")?;

    let config = Config::builder()
        .appender(Appender::builder().build("logfile", Box::new(logfile)))
        .build(Root::builder().appender("logfile").build(LogLevelFilter::Info))?;

    log4rs::init_config(config)?;

    info!("Hello, world!");

    Ok(())
}
#
# quick_main!(run);
```

[ex-tar-temp]: #ex-tar-temp
<a name="ex-tar-temp"></a>
## Unzip a tarball to a temporary directory

[![flate2-badge]][flate2] [![tar-badge]][tar] [![tempdir-badge]][tempdir] [![cat-filesystem-badge]][cat-filesystem] [![cat-compression-badge]][cat-compression]

Uncompress ([`flate2::read::GzDecoder::new`]) and
extract ([`tar::Archive::unpack`]) all files form a zipped tarball
named archive.tar.gz located in the current working directory
inside a temporary directory ([`tempdir::TempDir::new`])
and delete everything.

```rust,no_run
# #[macro_use]
# extern crate error_chain;
extern crate flate2;
extern crate tar;
extern crate tempdir;

use std::fs::File;
use flate2::read::GzDecoder;
use tar::Archive;
use tempdir::TempDir;
#
# error_chain! {
#    foreign_links {
#        Io(std::io::Error);
#    }
# }

fn run() -> Result<()> {
    let path = "archive.tar.gz";

    // Open our zipped tarball
    let tar_gz = File::open(path)?;
    // Uncompressed it
    let tar = GzDecoder::new(tar_gz)?;
    // Load the archive from the tarball
    let mut archive = Archive::new(tar);
    // Create a directory inside of `std::env::temp_dir()`, named with
    // the prefix "temp".
    let tmp_dir = TempDir::new("temp")?;
    // Unpack the archive inside the temporary directory
    archive.unpack(tmp_dir.path())?;

    Ok(())
}
#
# quick_main!(run);
```
[ex-dedup-filenames]: #ex-dedup-filenames
<a name="ex-dedup-filenames"></a>
## Recursively find duplicate file names

[![walkdir-badge]][walkdir] [![cat-filesystem-badge]][cat-filesystem]

Find recusively in the current directory duplicate filenames,
printing them only once.

```rust,no_run
extern crate walkdir;

use std::collections::HashMap;
use walkdir::WalkDir;

fn main() {
    // Counters indexed by filenames
    let mut filenames = HashMap::new();

    // List recusively all files in the current directory filtering out
    // directories and files not accessible (permission denied)
    for entry in WalkDir::new(".").into_iter()
                                  .filter_map(Result::ok)
                                  .filter(|e| !e.file_type().is_dir()) {
        // Get entry's filename
        let f_name = String::from(entry.file_name().to_string_lossy());
        // Get or initialize the counter
        let counter = filenames.entry(f_name.clone()).or_insert(0);
        // Update the counter
        *counter += 1;

        if *counter == 2 {
            println!("{}", f_name);
        }
    }
}
```

[ex-file-predicate]: #ex-file-predicate
<a name="ex-file-predicate"></a>
##  Recursively find all files with given predicate

Use the file names and metadata to recursively find in the current directory JSON files modified within the last day.

[![walkdir-badge]][walkdir] [![cat-filesystem-badge]][cat-filesystem]

```rust,no_run
# #[macro_use]
# extern crate error_chain;
extern crate walkdir;

use walkdir::WalkDir;
#
# error_chain! {
#    foreign_links {
#        WalkDir(walkdir::Error);
#        Io(std::io::Error);
#        SystemTime(std::time::SystemTimeError);
#    }
# }

fn run() -> Result<()> {
    // List recusively all accessible files in the current directory
    for entry in WalkDir::new(".").into_iter()
                                  .filter_map(|e| e.ok()) {
        // Get entry's filename
        let f_name = entry.file_name().to_string_lossy();
        // Get entry's modified time
        let sec = entry.metadata()?.modified()?;

        // Print JSON files modified within the last day
        if f_name.ends_with(".json") && sec.elapsed()?.as_secs() < 86400 {
            println!("{}", f_name);
        }
    }

    Ok(())
}
#
# quick_main!(run);
```

<!-- Categories -->

[cat-command-line-badge]: https://img.shields.io/badge/-command_line-red.svg
[cat-command-line]: https://crates.io/categories/command-line-interface
[cat-compression-badge]: https://img.shields.io/badge/-compression-red.svg
[cat-compression]: https://crates.io/categories/compression
[cat-debugging-badge]: https://img.shields.io/badge/-debugging-red.svg
[cat-debugging]: https://crates.io/categories/debugging
[cat-filesystem-badge]: https://img.shields.io/badge/-filesystem-red.svg
[cat-filesystem]: https://crates.io/categories/filesystem

<!-- Crates -->

[chrono-badge]: https://img.shields.io/crates/v/chrono.svg?label=chrono
[chrono]: https://docs.rs/chrono/
[clap-badge]: https://img.shields.io/crates/v/clap.svg?label=clap
[clap]: https://docs.rs/clap/
[env_logger-badge]: https://img.shields.io/crates/v/env_logger.svg?label=env_logger
[env_logger]: https://docs.rs/env_logger/
[flate2-badge]: https://img.shields.io/crates/v/flate2.svg?label=flate2
[flate2]: https://docs.rs/flate2/
[log-badge]: https://img.shields.io/crates/v/log.svg?label=log
[log]: https://docs.rs/log/
[syslog-badge]: https://img.shields.io/crates/v/syslog.svg?label=syslog
[syslog]: https://docs.rs/syslog/
[log4rs-badge]: https://img.shields.io/crates/v/log4rs.svg?label=log4rs
[log4rs]: https://docs.rs/log4rs/
[tar-badge]: https://img.shields.io/crates/v/tar.svg?label=tar
[tar]: https://docs.rs/tar/
[tempdir-badge]: https://img.shields.io/crates/v/tempdir.svg?label=tempdir
[tempdir]: https://docs.rs/tempdir/
[walkdir-badge]: https://img.shields.io/crates/v/walkdir.svg?label=walkdir
[walkdir]: https://docs.rs/walkdir/

<!-- Reference -->

[`DateTime::format`]: https://docs.rs/chrono/*/chrono/datetime/struct.DateTime.html#method.format
[`DateTime`]: https://docs.rs/chrono/*/chrono/datetime/struct.DateTime.html
[`Local::now`]: https://docs.rs/chrono/*/chrono/offset/local/struct.Local.html#method.now
[`LogBuilder::format`]: https://doc.rust-lang.org/log/env_logger/struct.LogBuilder.html#method.format
[`LogBuilder::init`]: https://doc.rust-lang.org/log/env_logger/struct.LogBuilder.html#method.init
[`LogBuilder::parse`]: https://doc.rust-lang.org/log/env_logger/struct.LogBuilder.html#method.parse
[`LogRecord::args`]: https://doc.rust-lang.org/log/log/struct.LogRecord.html#method.args
[`LogRecord::level`]: https://doc.rust-lang.org/log/log/struct.LogRecord.html#method.level
[`env_logger::LogBuilder`]: https://doc.rust-lang.org/log/env_logger/struct.LogBuilder.html
[`env_logger::init`]: https://doc.rust-lang.org/log/env_logger/fn.init.html
[`strftime::specifiers`]: https://docs.rs/chrono/*/chrono/format/strftime/index.html#specifiers
[`log4rs::append::file::FileAppender`]: https://docs.rs/log4rs/*/log4rs/append/file/struct.FileAppender.html
[`log4rs::encode::pattern`]: https://docs.rs/log4rs/*/log4rs/encode/pattern/index.html
[`log4rs::config::Config`]: https://docs.rs/log4rs/*/log4rs/config/struct.Config.html
[`syslog::init`]: https://docs.rs/syslog/*/syslog/fn.init.html
[`syslog::Facility`]: https://docs.rs/syslog/*/syslog/enum.Facility.html
[`log::LogLevel`]: https://doc.rust-lang.org/log/log/enum.LogLevel.html
[`log::LogLevelFilter`]: https://doc.rust-lang.org/log/log/enum.LogLevelFilter.html
[UNIX syslog]: https://www.gnu.org/software/libc/manual/html_node/Overview-of-Syslog.html
[`log::set_logger`]: https://doc.rust-lang.org/log/log/fn.set_logger.html
[`log::Log`]: https://doc.rust-lang.org/log/log/trait.Log.html
[`RUST_LOG`]: https://doc.rust-lang.org/log/env_logger/#enabling-logging
[`flate2::read::GzDecoder::new`]: https://docs.rs/flate2/0.2.19/flate2/read/struct.GzDecoder.html#method.new
[`tar::Archive::unpack`]: https://docs.rs/tar/0.4.12/tar/struct.Archive.html#method.new
[`tempdir::TempDir::new`]: https://docs.rs/tempdir/0.3.5/tempdir/struct.TempDir.html#method.new
