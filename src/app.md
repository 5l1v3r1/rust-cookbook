# Application development

| Recipe | Crates | Categories |
|--------|--------|------------|
| [Parse command line arguments][ex-clap-basic] | [![clap-badge]][clap] | [![cat-command-line-badge]][cat-command-line] |
| [Log a debug message to the console][ex-log-debug] | [![log-badge]][log] [![env_logger-badge]][env_logger] | [![cat-debugging-badge]][cat-debugging] |
| [Log an error message to the console][ex-log-error] | [![log-badge]][log] [![env_logger-badge]][env_logger] | [![cat-debugging-badge]][cat-debugging] |
| [Enable log levels per module][ex-log-mod] | [![log-badge]][log] [![env_logger-badge]][env_logger] | [![cat-debugging-badge]][cat-debugging] |
| [Log messages with a custom logger][ex-log-custom-logger] | [![log-badge]][log] | [![cat-debugging-badge]][cat-debugging] |
| [Log to the Unix syslog][ex-log-syslog] | [![log-badge]][log] [![syslog-badge]][syslog] | [![cat-debugging-badge]][cat-debugging] |
| [Log messages to a custom location][ex-log-custom] | [![log-badge]][log] | [![cat-debugging-badge]][cat-debugging] |
| [Unzip a tarball to a temporary directory][ex-tar-temp] | [![flate2-badge]][flate2] [![tar-badge]][tar] [![tempdir-badge]][tempdir] | [![cat-filesystem-badge]][cat-filesystem] [![cat-compression-badge]][cat-compression] |

[ex-clap-basic]: #ex-clap-basic
<a name="ex-clap-basic"></a>
## Parse command line arguments

[![clap-badge]][clap] [![cat-command-line-badge]][cat-command-line]

```rust
extern crate clap;

use clap::{Arg, App};

fn main() {
    // Define command line arguments.
    let matches = App::new("My Test Program")
        .version("0.1.0")
        .author("Hackerman Jones <hckrmnjones@hack.gov>")
        .about("Teaches argument parsing")
        .arg(Arg::with_name("file")
                 .short("f")
                 .long("file")
                 .takes_value(true)
                 .help("A cool file"))
        .arg(Arg::with_name("num")
                 .short("n")
                 .long("number")
                 .takes_value(true)
                 .help("Five less than your favorite number"))
        .get_matches();

    // Get value for file, or default to 'input.txt'.
    let myfile = matches.value_of("file").unwrap_or("input.txt");
    println!("The file passed is: {}", myfile);

    // Get value for num if present, and try parsing it as i32.
    let num_str = matches.value_of("num");
    match num_str {
        None => println!("No idea what your favorite number is."),
        Some(s) => {
            match s.parse::<i32>() {
                Ok(n) => println!("Your favorite number must be {}.", n + 5),
                Err(_) => println!("That's not a number! {}", s),
            }
        }
    }
}
```

The `clap` crate is a simple-to-use, efficient, and full-featured library for
parsing command line arguments and subcommands when writing console/terminal
applications.

The application can describe the structure of its command-line interface using
`clap`'s builder style. The [documentation] gives two other possible ways to
instantiate an application.

[documentation]: https://docs.rs/clap/

In the builder style, `with_name` is the unique identifier that `value_of` will
use to retrieve the value passed. The `short` and `long` options control the
flag the user will be expected to type; short flags look like `-f` and long
flags look like `--file`.

Usage information is generated by `clap`. The usage for the example application
looks like this.

```
My Test Program 0.1.0
Hackerman Jones <hckrmnjones@hack.gov>
Teaches argument parsing

USAGE:
    testing [OPTIONS]

FLAGS:
    -h, --help       Prints help information
    -V, --version    Prints version information

OPTIONS:
    -f, --file <file>     A cool file
    -n, --number <num>    Five less than your favorite number
```

We can test the application by running a command like the following.

```
$ cargo run -- -f myfile.txt -n 251
```

The output is:

```
The file passed is: myfile.txt
Your favorite number must be 256.
```

[ex-log-debug]: #ex-log-debug
<a name="ex-log-debug"></a>
## Log a debug message to the console

[![log-badge]][log] [![env_logger-badge]][env_logger] [![cat-debugging-badge]][cat-debugging]

[Write me!](https://github.com/brson/rust-cookbook/issues/61)

[ex-log-error]: #ex-log-error
<a name="ex-log-error"></a>
## Log an error message to the console

[![log-badge]][log] [![env_logger-badge]][env_logger] [![cat-debugging-badge]][cat-debugging]

[Write me!](https://github.com/brson/rust-cookbook/issues/61)

[ex-log-mod]: #ex-log-mod
<a name="ex-log-mod"></a>
## Enable log levels per module

[![log-badge]][log] [![env_logger-badge]][env_logger] [![cat-debugging-badge]][cat-debugging]

```rust
#[macro_use]
extern crate log;
extern crate env_logger;

#[macro_use]
extern crate error_chain;

mod foo {
    mod bar {
        pub fn run() {
            warn!("[bar] warn");
            info!("[bar] info");
            debug!("[bar] debug");
        }
    }

    pub fn run() {
        warn!("[foo] warn");
        info!("[foo] info");
        debug!("[foo] debug");
        bar::run();
    }
}

error_chain! {
    foreign_links {
        SetLogger(log::SetLoggerError);
    }
}

fn run() -> Result<()> {
    env_logger::init()?;
    warn!("[root] warn");
    info!("[root] info");
    debug!("[root] debug");
    foo::run();

    Ok(())
}

quick_main!(run);
```

[`env_logger`][env_logger] output is controlled by [`RUST_LOG`] environmental
variable on per module basis with comma separated entries in format `path::to::module=log_level`.
Assuming application `test` is run as follows:

```
RUST_LOG="warn,test::foo=info,test::foo::bar=debug" ./test
```

The default [`log::LogLevel`] is set to `warn`, while log levels for module `foo` and nested module `foo::bar` are set respectively to `info` and `debug`.

The output is:

```
WARN:test: [root] warn
WARN:test::foo: [foo] warn
INFO:test::foo: [foo] info
WARN:test::foo::bar: [bar] warn
INFO:test::foo::bar: [bar] info
DEBUG:test::foo::bar: [bar] debug
```

[ex-log-custom-logger]: #ex-log-custom-logger
<a name="ex-log-custom-logger"></a>
## Log messages with a custom logger

[![log-badge]][log] [![cat-debugging-badge]][cat-debugging]

Custom logger `ConsoleLogger` is implemented with [`log::Log`] trait and installed 
via [`log::set_logger`]. Messages are logged to stdout.

```rust
#[macro_use]
extern crate log;

#[macro_use]
extern crate error_chain;

use log::{LogRecord, LogLevel, LogMetadata, LogLevelFilter};

struct ConsoleLogger;

impl log::Log for ConsoleLogger {
    fn enabled(&self, metadata: &LogMetadata) -> bool {
        metadata.level() <= LogLevel::Info
    }

    fn log(&self, record: &LogRecord) {
        if self.enabled(record.metadata()) {
            println!("Rust says: {} - {}", record.level(), record.args());
        }
    }
}

error_chain! {
    foreign_links {
        SetLogger(log::SetLoggerError);
    }
}

fn run() -> Result<()> {
    log::set_logger(|max_log_level| {
                        max_log_level.set(LogLevelFilter::Info);
                        Box::new(ConsoleLogger)
                    })?;
    
    info!("hello log");
    warn!("warning");
    error!("oops");
    Ok(())
}

quick_main!(run);
```

[ex-log-syslog]: #ex-log-syslog
<a name="ex-log-syslog"></a>
## Log to the Unix syslog

[![log-badge]][log] [![syslog-badge]][syslog] [![cat-debugging-badge]][cat-debugging]

Messages are logged to [UNIX syslog]. Logger backend is initialized
with [`syslog::init`].
[`syslog::Facility`] indicates type of program submitting log.
[`log::LogLevelFilter`] denotes allowed log verbosity
and `Option<&str>` holds optional application name.

```rust,no_run
#[macro_use]
extern crate log;
extern crate syslog;

#[macro_use]
extern crate error_chain;

use log::LogLevelFilter;
use syslog::Facility;

error_chain! {
    foreign_links {
        SetLogger(log::SetLoggerError);
    }
}

fn run() -> Result<()> {
    syslog::init(Facility::LOG_USER, LogLevelFilter::Debug, Some("My app name"))?;
    debug!("this is a debug {}", "message");
    error!("this is an error!");
    Ok(())
}

quick_main!(run);
```

[ex-log-custom]: #ex-log-custom
<a name="ex-log-custom"></a>
## Log messages to a custom location

[![log-badge]][log] [![cat-debugging-badge]][cat-debugging]

[Write me!](https://github.com/brson/rust-cookbook/issues/61)

[ex-tar-temp]: #ex-tar-temp
<a name="ex-tar-temp"></a>
## Unzip a tarball to a temporary directory

Uncompress ([`flate2::read::GzDecoder::new`]) and
extract ([`tar::Archive::unpack`]) all files form a zipped tarball
named archive.tar.gz located in the current working directory
inside a temporary directory ([`tempdir::TempDir::new`])
and delete everything.

[![flate2-badge]][flate2] [![tar-badge]][tar] [![tempdir-badge]][tempdir] [![cat-filesystem-badge]][cat-filesystem] [![cat-compression-badge]][cat-compression]

```rust,no_run
#[macro_use]
extern crate error_chain;
extern crate flate2;
extern crate tar;
extern crate tempdir;

use std::fs::File;

use flate2::read::GzDecoder;
use tar::Archive;
use tempdir::TempDir;


error_chain! {
    foreign_links {
        Io(std::io::Error);
    }
}

fn run() -> Result<()> {
    let path = "archive.tar.gz";

    // Open our zipped tarball
    let tar_gz = File::open(path)?;
    // Uncompressed it
    let tar = GzDecoder::new(tar_gz)?;
    // Load the archive from the tarball
    let mut archive = Archive::new(tar);
    // Create a directory inside of `std::env::temp_dir()`, named with
    // the prefix "temp".
    let tmp_dir = TempDir::new("temp")?;
    // Unpack the archive inside the temporary directory
    archive.unpack(tmp_dir.path())?;

    Ok(())
}

quick_main!(run);
```

<!-- Categories -->

[cat-command-line-badge]: https://img.shields.io/badge/-command_line-red.svg
[cat-command-line]: https://crates.io/categories/command-line-interface
[cat-compression-badge]: https://img.shields.io/badge/-compression-red.svg
[cat-compression]: https://crates.io/categories/compression
[cat-debugging-badge]: https://img.shields.io/badge/-debugging-red.svg
[cat-debugging]: https://crates.io/categories/debugging
[cat-filesystem-badge]: https://img.shields.io/badge/-filesystem-red.svg
[cat-filesystem]: https://crates.io/categories/filesystem

<!-- Crates -->

[clap-badge]: https://img.shields.io/crates/v/clap.svg?label=clap
[clap]: https://docs.rs/clap/
[env_logger-badge]: https://img.shields.io/crates/v/env_logger.svg?label=env_logger
[env_logger]: https://docs.rs/env_logger/
[flate2-badge]: https://img.shields.io/crates/v/flate2.svg?label=flate2
[flate2]: https://docs.rs/flate2/
[log-badge]: https://img.shields.io/crates/v/log.svg?label=log
[log]: https://docs.rs/log/
[syslog-badge]: https://img.shields.io/crates/v/syslog.svg?label=syslog
[syslog]: https://docs.rs/syslog/
[tar-badge]: https://img.shields.io/crates/v/tar.svg?label=tar
[tar]: https://docs.rs/tar/
[tempdir-badge]: https://img.shields.io/crates/v/tempdir.svg?label=tempdir
[tempdir]: https://docs.rs/tempdir/

<!-- Reference -->

[`syslog::init`]: https://docs.rs/syslog/*/syslog/fn.init.html
[`syslog::Facility`]: https://docs.rs/syslog/*/syslog/enum.Facility.html
[`log::LogLevel`]: https://doc.rust-lang.org/log/log/enum.LogLevel.html
[`log::LogLevelFilter`]: https://doc.rust-lang.org/log/log/enum.LogLevelFilter.html
[UNIX syslog]: https://www.gnu.org/software/libc/manual/html_node/Overview-of-Syslog.html
[`log::set_logger`]: https://doc.rust-lang.org/log/log/fn.set_logger.html
[`log::Log`]: https://doc.rust-lang.org/log/log/trait.Log.html
[`RUST_LOG`]: https://doc.rust-lang.org/log/env_logger/#enabling-logging
[`flate2::read::GzDecoder::new`]: https://docs.rs/flate2/0.2.19/flate2/read/struct.GzDecoder.html#method.new
[`tar::Archive::unpack`]: https://docs.rs/tar/0.4.12/tar/struct.Archive.html#method.new
[`tempdir::TempDir::new`]: https://docs.rs/tempdir/0.3.5/tempdir/struct.TempDir.html#method.new
